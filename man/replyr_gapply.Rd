% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/groupedApply.R
\name{replyr_gapply}
\alias{replyr_gapply}
\title{grouped apply}
\usage{
replyr_gapply(df, gcolumn, f, ocolumn = NULL, ..., maxgroups = 1000)
}
\arguments{
\item{df}{remote dplyr data item}

\item{gcolumn}{grouping column}

\item{f}{transform function}

\item{ocolumn}{ordering column (optional)}

\item{...}{force later values to be bound by name}

\item{maxgroups}{maximum number of groups to work over}
}
\value{
transformed frame
}
\description{
Partitions from by values in grouping column, applies a generic transform
to each group and then binds the groups back together.  This is powerfull
enough to implement "The Split-Apply-Combine Strategy for Data Analysis"
https://www.jstatsoft.org/article/view/v040i01
}
\examples{

library('dplyr')
d <- data.frame(group=c(1,1,2,2,2),
                order=c(1,2,3,4,5),
                values=c(10,20,2,4,8))

cumulative_sum <- function(dg) {
  dg \%>\% mutate(cv=cumsum(values))
}

sumgroup <- function(dg) {
  dg \%>\% summarize(group=min(group), # pseudo aggregation, group constant
                   minv=min(values),maxv=max(values))
}

d \%>\% replyr_gapply('group',cumulative_sum,'order')
d \%>\% replyr_gapply('group',sumgroup)

# # below only works for services which have a cumsum operator
# my_db <- dplyr::src_postgres(host = 'localhost',port = 5432,user = 'postgres',password = 'pg')
# dR <- replyr_copy_to(my_db,d,'dR')
# dR \%>\% replyr_gapply('group',cumulative_sum,'order')
# dR \%>\% replyr_gapply('group',sumgroup)

}

